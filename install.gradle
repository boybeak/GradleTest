import java.util.zip.ZipFile

// 定义 ANSI 颜色代码
class Colors {
    static final String RESET = "\u001B[0m"
    static final String RED = "\u001B[31m"
    static final String GREEN = "\u001B[32m"
    static final String YELLOW = "\u001B[33m"
    static final String BLUE = "\u001B[34m"
}

// 将日志方法添加到 extra 属性中，以便在整个脚本中调用
ext {
    logInfo = { message ->
        println "${Colors.BLUE}[INFO] $message${Colors.RESET}"
    }
    logSuccess = { message ->
        println "${Colors.GREEN}[SUCCESS] $message${Colors.RESET}"
    }
    logWarning = { message ->
        println "${Colors.YELLOW}[WARNING] $message${Colors.RESET}"
    }
    logError = { message ->
        println "${Colors.RED}[ERROR] $message${Colors.RESET}"
    }

    repositoryRoot = {
        File current = project.projectDir
        while (current.exists() && !new File(current, ".git").exists()) {
            current = current.parentFile
        }
        if (!current.exists()) {
            throw new IllegalStateException("No .git found in this project")
        }
        return current
    }
    gitRoot = new File(repositoryRoot(), ".git")
    gitHooksDir = new File(gitRoot, "hooks")
    preCommitFile = new File(gitHooksDir, "pre-commit")
    resCheckerFile = new File(gitRoot, "cli/res-checker.jar")

    toolsZipUrl = "https://github.com/boybeak/GradleTest/raw/refs/heads/main/tools.zip"
}

// 格式化字节数为可读格式
def formatBytes = { bytes ->
    def units = ['B', 'KB', 'MB', 'GB', 'TB']
    def unitIndex = 0
    def size = bytes.toDouble()

    while (size >= 1024 && unitIndex < units.size() - 1) {
        size /= 1024
        unitIndex++
    }

    if (unitIndex == 0) {
        return "${size.toInt()}${units[unitIndex]}"
    } else {
        return "${String.format('%.1f', size)}${units[unitIndex]}"
    }
}

def download = { url, dstFile ->
    // 确保目标文件是 File 对象
    File dest = dstFile instanceof File ? dstFile : new File(dstFile.toString())

    // 创建目标目录
    dest.parentFile.mkdirs()

    logInfo "开始下载: $url"
    logInfo "保存路径: ${dest.absolutePath}"

    try {
        // 创建连接（支持HTTP/HTTPS）
        def connection = new URL(url).openConnection()
        connection.connectTimeout = 15000 // 15秒连接超时
        connection.readTimeout = 30000    // 30秒读取超时

        // 验证响应（检查HTTP 200）
        def responseCode = connection.responseCode
        if (responseCode != 200) {
            throw new IOException("HTTP错误: $responseCode - ${connection.responseMessage}")
        }

        // 获取文件总大小
        def contentLength = connection.contentLength
        def totalSize = contentLength > 0 ? contentLength : -1
        def totalSizeStr = totalSize > 0 ? formatBytes(totalSize) : "未知大小"

        // 流式写入文件并显示进度
        def bufferSize = 8192
        def buffer = new byte[bufferSize]
        def bytesRead = 0
        def totalBytesRead = 0
        def startTime = System.currentTimeMillis()
        def lastUpdateTime = startTime
        def lastBytesRead = 0

        dest.withOutputStream { out ->
            def input = connection.inputStream
            while ((bytesRead = input.read(buffer)) != -1) {
                out.write(buffer, 0, bytesRead)
                totalBytesRead += bytesRead

                // 每500ms更新一次进度信息
                def currentTime = System.currentTimeMillis()
                if (currentTime - lastUpdateTime >= 500) {
                    def elapsedTime = (currentTime - startTime) / 1000.0
                    def speed = (totalBytesRead - lastBytesRead) / ((currentTime - lastUpdateTime) / 1000.0)

                    def progressInfo
                    if (totalSize > 0) {
                        def progress = (totalBytesRead * 100.0 / totalSize)
                        def downloadedStr = formatBytes(totalBytesRead)
                        progressInfo = String.format("\r下载进度: %s/%s (%.1f%%) | 速度: %s/s",
                                downloadedStr, totalSizeStr, progress, formatBytes(speed))
                    } else {
                        def downloadedStr = formatBytes(totalBytesRead)
                        progressInfo = String.format("\r已下载: %s | 速度: %s/s | 时间: %.1fs",
                                downloadedStr, formatBytes(speed), elapsedTime)
                    }

                    // 打印进度信息（不换行）
                    System.out.print(progressInfo)
                    System.out.flush()

                    lastUpdateTime = currentTime
                    lastBytesRead = totalBytesRead
                }
            }

            // 下载完成后换行
            System.out.println()
        }

        def endTime = System.currentTimeMillis()
        def totalTime = (endTime - startTime) / 1000.0
        def averageSpeed = totalBytesRead / totalTime

        logSuccess "✅下载成功 | 总大小: ${formatBytes(totalBytesRead)} | 耗时: ${String.format('%.1f', totalTime)}s | 平均速度: ${formatBytes(averageSpeed)}/s"
    } catch (Exception e) {
        System.out.println() // 换行避免错误信息覆盖进度信息
        logError "❎下载失败: ${e.message}"
    }
}

def isZipValid = { zipFile ->
    try {
        new ZipFile(zipFile).close()
        return true
    } catch (IOException ignored) {
        return false
    }
}
def uninstall = {
    if (preCommitFile.exists()) {
        preCommitFile.delete()
    }
    if (resCheckerFile.exists()) {
        resCheckerFile.delete()
    }
}
def install = { Boolean force = false ->
    if (force) {
        uninstall()
    }

    if (preCommitFile.exists() && resCheckerFile.exists()) {
        logInfo "已安装CodeQualityTools, 强制更新请执行: ./gradlew forceReinstallCQT"
        return
    }

    File tempZip = File.createTempFile("tools", ".zip")

    download(toolsZipUrl, tempZip)

    if (!tempZip.exists()) {
        logError "❎下载目标文件不成功"
        return
    }
    if (!isZipValid(tempZip)) {
        logError "zip文件损坏"
        return
    }

    def cqtConfig = [:]
    cqtConfig.sizeMin = parseDimension(project.properties['cqt.sizeMin'], [width: 48, height: 48])
    cqtConfig.sizeMax = parseDimension(project.properties['cqt.sizeMax'], [width: 1080, height: 1920])
    cqtConfig.fileSizeRange = parseFileSizeRange(project.properties['cqt.fileSizeRange'], [min: 2 * 1024, max: 200 * 1024])

    logInfo "🔛开始解压到目标路径..."
    project.copy {
        from zipTree(tempZip)
        into(gitRoot)

        filesMatching("**/hooks/pre-commit") {
            filter { line ->
                return line.replace('${PROJECT_NAME}', "PROJECT_NAME=\"${project.name}\"")
                        .replace('${JAVA_HOME}', "JAVA_HOME=\"${System.getProperty("java.home")}\"")
                        .replace('${WIDTH_RANGE}', "WIDTH_RANGE=\"${cqtConfig.sizeMin.width} ${cqtConfig.sizeMax.width}\"")
                        .replace('${HEIGHT_RANGE}', "HEIGHT_RANGE=\"${cqtConfig.sizeMin.height} ${cqtConfig.sizeMax.height}\"")
                        .replace('${FILE_SIZE_RANGE}', "FILE_SIZE_RANGE=\"${cqtConfig.fileSizeRange.min} ${cqtConfig.fileSizeRange.max}\"")
            }
        }
    }
    logSuccess "✅解压成功"

    if (preCommitFile.exists()) {
        preCommitFile.setExecutable(true, false)
    }
    if (resCheckerFile.exists()) {
        resCheckerFile.setExecutable(true, false)
    }
}

task forceReinstallCQT() {
    doLast {
        install(true)
    }
}

task uninstallCQT() {
    doLast {
        logInfo "卸载中..."
        uninstall()
        logSuccess "✅卸载成功"
    }
}

afterEvaluate {
    install()
}

// 自定义解析函数：计算表达式字符串的值
static def computeExpression(String expr) {
    // 去除所有空格并分割乘数
    def parts = expr.replaceAll("\\s", "").split("\\*")
    // 计算结果
    def result = 1
    parts.each { num ->
        result *= num.toInteger()
    }
    return result
}

// 解析尺寸配置（如 "48*48"）
static def parseDimension(String dimStr, defaultValue) {
    try {
        def parts = dimStr.split("\\*")
        return [
                width: computeExpression(parts[0]),
                height: computeExpression(parts[1])
        ]
    } catch (Exception e) {
        return defaultValue
    }
}

// 解析文件大小范围（如 "[2 * 1024, 2 * 1024 * 1024]"）
static def parseFileSizeRange(String rangeStr, defaultValue) {
    try {
        // 移除方括号和空格
        def cleanStr = rangeStr.replaceAll("[\\[\\]\\s]", "")
        // 分割为两个表达式
        def expressions = cleanStr.split(",")

        if (expressions.size() != 2) {
            return defaultValue
        }

        return [
                min: computeExpression(expressions[0]),
                max: computeExpression(expressions[1])
        ]
    } catch (Exception e) {
        return defaultValue
    }
}