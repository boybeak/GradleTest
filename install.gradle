import java.nio.file.Files
import java.nio.file.StandardCopyOption
import java.util.zip.ZipFile

// å®šä¹‰ ANSI é¢œè‰²ä»£ç 
class Colors {
    static final String RESET = "\u001B[0m"
    static final String RED = "\u001B[31m"
    static final String GREEN = "\u001B[32m"
    static final String YELLOW = "\u001B[33m"
    static final String BLUE = "\u001B[34m"
}

// å°†æ—¥å¿—æ–¹æ³•æ·»åŠ åˆ° extra å±æ€§ä¸­ï¼Œä»¥ä¾¿åœ¨æ•´ä¸ªè„šæœ¬ä¸­è°ƒç”¨
ext {
    logInfo = { message ->
        println "${Colors.BLUE}[INFO] $message${Colors.RESET}"
    }
    logSuccess = { message ->
        println "${Colors.GREEN}[SUCCESS] $message${Colors.RESET}"
    }
    logWarning = { message ->
        println "${Colors.YELLOW}[WARNING] $message${Colors.RESET}"
    }
    logError = { message ->
        println "${Colors.RED}[ERROR] $message${Colors.RESET}"
    }

    repositoryRoot = {
        File current = project.projectDir
        while (current.exists() && !new File(current, ".git").exists()) {
            current = current.parentFile
        }
        if (!current.exists()) {
            throw new IllegalStateException("No .git found in this project")
        }
        return current
    }
    repositoryRootDir = repositoryRoot()
    gitRoot = new File(repositoryRoot(), ".git")
    gitHooksDir = new File(gitRoot, "hooks")
    preCommitFile = new File(gitHooksDir, "pre-commit")
    postCommitFile = new File(gitHooksDir, "post-commit")
    postCheckoutFile = new File(gitHooksDir, "post-checkout")
    postUpdateFile = new File(gitHooksDir, "post-update")
    createBaselineFile = new File(gitHooksDir, "create-baseline")

    resCheckerFile = new File(gitRoot, "cli/res-checker.jar")
    detektDir = new File(gitRoot, "detekt")
    detektConfigDir= new File(detektDir, "config")
    baselineFile = new File(detektConfigDir, "baseline.xml")
    toolsZipFile = new File(gitRoot, "tools.zip")
    gradlePropertiesFile = new File(project.projectDir, "gradle.properties")

    toolsZipUrl = "https://github.com/boybeak/GradleTest/raw/refs/heads/main/tools.zip"

    // æ ¼å¼åŒ–å­—èŠ‚æ•°ä¸ºå¯è¯»æ ¼å¼
    def formatBytes = { bytes ->
        def units = ['B', 'KB', 'MB', 'GB', 'TB']
        def unitIndex = 0
        def size = bytes.toDouble()

        while (size >= 1024 && unitIndex < units.size() - 1) {
            size /= 1024
            unitIndex++
        }

        if (unitIndex == 0) {
            return "${size.toInt()}${units[unitIndex]}"
        } else {
            return "${String.format('%.1f', size)}${units[unitIndex]}"
        }
    }

    download = { url, dstFile ->
        // ç¡®ä¿ç›®æ ‡æ–‡ä»¶æ˜¯ File å¯¹è±¡
        File dest = dstFile instanceof File ? dstFile : new File(dstFile.toString())

        // åˆ›å»ºç›®æ ‡ç›®å½•
        dest.parentFile.mkdirs()

        logInfo "å¼€å§‹ä¸‹è½½: $url"
        logInfo "ä¿å­˜è·¯å¾„: ${dest.absolutePath}"

        try {
            // åˆ›å»ºè¿æ¥ï¼ˆæ”¯æŒHTTP/HTTPSï¼‰
            def connection = new URL(url).openConnection()
            connection.connectTimeout = 15000 // 15ç§’è¿æ¥è¶…æ—¶
            connection.readTimeout = 30000    // 30ç§’è¯»å–è¶…æ—¶

            // éªŒè¯å“åº”ï¼ˆæ£€æŸ¥HTTP 200ï¼‰
            def responseCode = connection.responseCode
            if (responseCode != 200) {
                throw new IOException("HTTPé”™è¯¯: $responseCode - ${connection.responseMessage}")
            }

            // è·å–æ–‡ä»¶æ€»å¤§å°
            def contentLength = connection.contentLength
            def totalSize = contentLength > 0 ? contentLength : -1
            def totalSizeStr = totalSize > 0 ? formatBytes(totalSize) : "æœªçŸ¥å¤§å°"

            // æµå¼å†™å…¥æ–‡ä»¶å¹¶æ˜¾ç¤ºè¿›åº¦
            def bufferSize = 8192
            def buffer = new byte[bufferSize]
            def bytesRead = 0
            def totalBytesRead = 0
            def startTime = System.currentTimeMillis()
            def lastUpdateTime = startTime
            def lastBytesRead = 0

            dest.withOutputStream { out ->
                def input = connection.inputStream
                while ((bytesRead = input.read(buffer)) != -1) {
                    out.write(buffer, 0, bytesRead)
                    totalBytesRead += bytesRead

                    // æ¯500msæ›´æ–°ä¸€æ¬¡è¿›åº¦ä¿¡æ¯
                    def currentTime = System.currentTimeMillis()
                    if (currentTime - lastUpdateTime >= 500) {
                        def elapsedTime = (currentTime - startTime) / 1000.0
                        def speed = (totalBytesRead - lastBytesRead) / ((currentTime - lastUpdateTime) / 1000.0)

                        def progressInfo
                        if (totalSize > 0) {
                            def progress = (totalBytesRead * 100.0 / totalSize)
                            def downloadedStr = formatBytes(totalBytesRead)
                            progressInfo = String.format("\rä¸‹è½½è¿›åº¦: %s/%s (%.1f%%) | é€Ÿåº¦: %s/s",
                                    downloadedStr, totalSizeStr, progress, formatBytes(speed))
                        } else {
                            def downloadedStr = formatBytes(totalBytesRead)
                            progressInfo = String.format("\rå·²ä¸‹è½½: %s | é€Ÿåº¦: %s/s | æ—¶é—´: %.1fs",
                                    downloadedStr, formatBytes(speed), elapsedTime)
                        }

                        // æ‰“å°è¿›åº¦ä¿¡æ¯ï¼ˆä¸æ¢è¡Œï¼‰
                        System.out.print(progressInfo)
                        System.out.flush()

                        lastUpdateTime = currentTime
                        lastBytesRead = totalBytesRead
                    }
                }

                // ä¸‹è½½å®Œæˆåæ¢è¡Œ
                System.out.println()
            }

            def endTime = System.currentTimeMillis()
            def totalTime = (endTime - startTime) / 1000.0
            def averageSpeed = totalBytesRead / totalTime

            logSuccess "âœ…ä¸‹è½½æˆåŠŸ | æ€»å¤§å°: ${formatBytes(totalBytesRead)} | è€—æ—¶: ${String.format('%.1f', totalTime)}s | å¹³å‡é€Ÿåº¦: ${formatBytes(averageSpeed)}/s"
        } catch (Exception e) {
            System.out.println() // æ¢è¡Œé¿å…é”™è¯¯ä¿¡æ¯è¦†ç›–è¿›åº¦ä¿¡æ¯
            logError "âä¸‹è½½å¤±è´¥: ${e.message}"
        }
    }

    isZipValid = { zipFile ->
        try {
            new ZipFile(zipFile).close()
            return true
        } catch (IOException ignored) {
            return false
        }
    }
    uninstallCQT = {
        if (preCommitFile.exists()) {
            preCommitFile.delete()
        }
        if (postCommitFile.exists()) {
            postCommitFile.delete()
        }
        if (postCheckoutFile.exists()) {
            postCheckoutFile.delete()
        }
        if (postUpdateFile.exists()) {
            postUpdateFile.delete()
        }
        if (createBaselineFile.exists()) {
            createBaselineFile.delete()
        }
        if (resCheckerFile.exists()) {
            resCheckerFile.delete()
        }
        if (detektDir.exists()) {
            delete detektDir
        }
    }
    isFullInstall = {
        File detektCli = new File(detektDir, "bin/detekt-cli")
        File detektConfigYml = new File(detektDir, "config/detekt.yml")
        File libDir = new File(detektDir, "lib")  // è·å–libç›®å½•

        // æ£€æŸ¥libç›®å½•ä¸‹æ˜¯å¦å­˜åœ¨åŒ¹é… detekt-cli-*.jar çš„æ–‡ä»¶
        boolean hasDetektCliJar = libDir.exists() && libDir.isDirectory() &&
                libDir.listFiles().any { file ->
                    file.name.startsWith("detekt-cli-") && file.name.endsWith(".jar")
                }

        return preCommitFile.exists() && resCheckerFile.exists() && detektDir.exists() &&
                detektCli.exists() && detektConfigYml.exists() && hasDetektCliJar  // ä½¿ç”¨æ–°æ£€æŸ¥æ¡ä»¶
    }
    unzipInstall = { zipFile ->
        def cqtConfig = [:]
        cqtConfig.sizeMin = parseDimension(project.properties['cqt.sizeMin'], [width: 48, height: 48])
        cqtConfig.sizeMax = parseDimension(project.properties['cqt.sizeMax'], [width: 1080, height: 1920])
        cqtConfig.fileSizeRange = parseFileSizeRange(project.properties['cqt.fileSizeRange'], [min: 2 * 1024, max: 200 * 1024])
        cqtConfig.showDialog = project.properties['cqt.showDialog'] != 'false'
        cqtConfig.openDetektReport = project.properties['cqt.openDetektReport'] != 'false'
        cqtConfig.customDetektRules = project.properties['cqt.customDetektRules']

        project.copy {
            from zipTree(zipFile)
            into(gitRoot)

            filesMatching("**/hooks/pre-commit") {
                filter { line ->
                    return line.replace('${PROJECT_NAME}', "PROJECT_NAME=\"${project.name}\"")
                            .replace('${JAVA_HOME}', "JAVA_HOME=\"${System.getProperty("java.home")}\"")
                            .replace('${WIDTH_RANGE}', "WIDTH_RANGE=\"${cqtConfig.sizeMin.width} ${cqtConfig.sizeMax.width}\"")
                            .replace('${HEIGHT_RANGE}', "HEIGHT_RANGE=\"${cqtConfig.sizeMin.height} ${cqtConfig.sizeMax.height}\"")
                            .replace('${FILE_SIZE_RANGE}', "FILE_SIZE_RANGE=\"${cqtConfig.fileSizeRange.min} ${cqtConfig.fileSizeRange.max}\"")
                            .replace('${SHOW_DIALOG}', "SHOW_DIALOG=\"${cqtConfig.showDialog}\"")
                            .replace('${OPEN_DETEKT_REPORT}', "OPEN_DETEKT_REPORT=\"${cqtConfig.openDetektReport}\"")
                            .with { str ->
                                if (cqtConfig.customDetektRules != null) {
                                    File customRulesFile = new File(project.projectDir, cqtConfig.customDetektRules)
                                    if (customRulesFile.exists()) {
                                        str.replace('${CUSTOM_DETEKT_RULES}', "CUSTOM_DETEKT_RULES=\"${customRulesFile.absolutePath}\"")
                                    } else {
                                        str
                                    }
                                } else {
                                    str
                                }
                            }
                }
            }
        }

        logInfo cqtConfig

        if (preCommitFile.exists()) {
            preCommitFile.setExecutable(true, false)
        }
        if (postCommitFile.exists()) {
            postCommitFile.setExecutable(true, false)
        }
        if (postCheckoutFile.exists()) {
            postCheckoutFile.setExecutable(true, false)
        }
        if (postUpdateFile.exists()) {
            postUpdateFile.setExecutable(true, false)
        }
        if (createBaselineFile.exists()) {
            createBaselineFile.setExecutable(true, false)
        }
        if (resCheckerFile.exists()) {
            resCheckerFile.setExecutable(true, false)
        }
    }
    installCQT = { Boolean force = false ->
        if (force) {
            uninstallCQT()
        }

        if (isFullInstall()) {
            logInfo "å·²å®‰è£…CodeQualityTools, å¼ºåˆ¶æ›´æ–°è¯·æ‰§è¡Œ: ./gradlew forceUpdateCQT"
            return
        }

        File tempZip = File.createTempFile("tools", ".zip")

        download(toolsZipUrl, tempZip)

        if (!tempZip.exists()) {
            logError "âä¸‹è½½ç›®æ ‡æ–‡ä»¶ä¸æˆåŠŸ"
            return
        }
        if (!isZipValid(tempZip)) {
            logError "zipæ–‡ä»¶æŸå"
            return
        }

        logInfo "ğŸ”›å¼€å§‹è§£å‹åˆ°ç›®æ ‡è·¯å¾„..."
        unzipInstall(tempZip)
        logSuccess "âœ…å®‰è£…æˆåŠŸ, å¼€å§‹åˆå§‹åŒ–..."
        if (!baselineFile.exists()) {
            detektConfigDir.mkdirs()
            exec {
                workingDir repositoryRootDir.absolutePath
                commandLine './.git/detekt/bin/detekt-cli',
                        '--input', "${project.projectDir.absolutePath}/",
                        '--excludes', '"**/test/**,**/androidTest/**,**/build/**"',
                        '--config', './.git/detekt/config/detekt.yml',
                        '--baseline', "${baselineFile.absolutePath}",
                        '--parallel',
                        '--create-baseline'
                ignoreExitValue = true
            }

        }
        if (baselineFile.exists()) {
            logSuccess "âœ…åˆå§‹åŒ–æˆåŠŸ"
        } else {
            logError "âåˆå§‹åŒ–å¤±è´¥"
        }

        Files.copy(tempZip.toPath(), toolsZipFile.toPath(), StandardCopyOption.REPLACE_EXISTING)
    }
    shouldUpdateConfig = {
        return gradlePropertiesFile.lastModified() > preCommitFile.lastModified()
    }
}

task forceUpdateCQT() {
    doLast {
        installCQT(true)
    }
}

task uninstallCQT() {
    doLast {
        logInfo "å¸è½½ä¸­..."
        uninstallCQT()
        logSuccess "âœ…å¸è½½æˆåŠŸ"
    }
}

task createBaseline() {
    doLast {
        exec {
            workingDir repositoryRootDir.absolutePath
            commandLine './.git/detekt/bin/detekt-cli',
                    '--input', "${project.projectDir.absolutePath}/",
                    '--excludes', '"**/test/**,**/androidTest/**,**/build/**"',
                    '--config', './.git/detekt/config/detekt.yml',
                    '--baseline', './.git/detekt/config/baseline.xml',
                    '--parallel',
                    '--create-baseline'
        }
    }
}

afterEvaluate {
    if (isFullInstall() && toolsZipFile.exists() && shouldUpdateConfig()) {
        logInfo "ğŸ”›æ›´æ–°é…ç½®ä¸­..."
        uninstallCQT()
        unzipInstall(toolsZipFile)
        logInfo "âœ…æ›´æ–°å®Œæˆ"
    } else {
        installCQT()
    }
}

// è‡ªå®šä¹‰è§£æå‡½æ•°ï¼šè®¡ç®—è¡¨è¾¾å¼å­—ç¬¦ä¸²çš„å€¼
static def computeExpression(String expr) {
    // å»é™¤æ‰€æœ‰ç©ºæ ¼å¹¶åˆ†å‰²ä¹˜æ•°
    def parts = expr.replaceAll("\\s", "").split("\\*")
    // è®¡ç®—ç»“æœ
    def result = 1
    parts.each { num ->
        result *= num.toInteger()
    }
    return result
}

// è§£æå°ºå¯¸é…ç½®ï¼ˆå¦‚ "48*48"ï¼‰
static def parseDimension(String dimStr, defaultValue) {
    try {
        def parts = dimStr.split("\\*")
        return [
                width: computeExpression(parts[0]),
                height: computeExpression(parts[1])
        ]
    } catch (Exception e) {
        return defaultValue
    }
}

// è§£ææ–‡ä»¶å¤§å°èŒƒå›´ï¼ˆå¦‚ "[2 * 1024, 2 * 1024 * 1024]"ï¼‰
static def parseFileSizeRange(String rangeStr, defaultValue) {
    try {
        // ç§»é™¤æ–¹æ‹¬å·å’Œç©ºæ ¼
        def cleanStr = rangeStr.replaceAll("[\\[\\]\\s]", "")
        // åˆ†å‰²ä¸ºä¸¤ä¸ªè¡¨è¾¾å¼
        def expressions = cleanStr.split(",")

        if (expressions.size() != 2) {
            return defaultValue
        }

        return [
                min: computeExpression(expressions[0]),
                max: computeExpression(expressions[1])
        ]
    } catch (Exception e) {
        return defaultValue
    }
}